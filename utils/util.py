#!/usr/bin/python
# -*- coding: utf-8 -*-

from utils.to_json import *

UNIT_NAME = 'utP1c0CD'
UNIT_ELEMENT = 'iNy0ZU5M'
UNIT_RARITY = '7ofj5xa1'
UNIT_BASE_HP = 'UZ1Bj7w2'
UNIT_LORD_HP = '3WMz78t6'
UNIT_BASE_ATK = 'i9Tn7kYr'
UNIT_LORD_ATK = 'omuyP54D'
UNIT_BASE_DEF = 'q78KoWsg'
UNIT_LORD_DEF = '32INDST4'
UNIT_BASE_REC = '92ij6UGB'
UNIT_LORD_REC = 'X9P3AN5d'
UNIT_MAX_LEVEL = 'EI1DF8Yt'
UNIT_IMP = 'imQJdg64'
UNIT_ID = 'pn16CNah'
UNIT_GUIDE_ID = 'XuJL4pc5'
UNIT_EXP_PATTERN_ID = '5UvTp7q1'
UNIT_AI_ID = 'i74vGUFa'
UNIT_COST = 'gvT2ds0Q'
UNIT_OD_STATS = '5SUvj4tM'
UNIT_GENDER = '9i2xhMaJ'
UNIT_GETTING_TYPE = '6yHMXYv1'
UNIT_CATEGORY = '9PsmH7tz'
UNIT_KIND = 'xP9oi5Z2'
UNIT_ATTACK_MOVE_TYPE = 'mv4o39Uz'
UNIT_SKILL_MOVE_TYPE = 'XE7Yi5c3'
UNIT_MOVE_SPEED = 'J2hPXGo5'
SELL_CAUTION = 'y4jAZ9nI'
DMG_FRAME = '6Aou5M9r'
DROP_CHECK_CNT = 'n9h7p02P'
BB_ID = 'nj9Lw7mV'
SBB_ID = 'iEFZ6H19'
UBB_ID = 'cb0P4mp1'
BB_NAME = '0nxpBDz2'
SKILL_LEVELS_PROCESSES = 'Kn51uR4Y'
SKILL_START_FRAME = 'qYCx73y2'
SKILL_TARGET_AREA = 'IZt73kLG'
LS_ID = 'oS3kTZ2W'
LS_NAME = 'dJPf9a5v'
LS_PROCESS = '2Smu5Mtq'
PROCESS_TYPE = 'hjAy9St3'
DESC = 'qp37xTDh'

AI_ID = '4eEVw5hL'
AI_CHANCE = 'ug9xV4Fz'
AI_TARGET_CONDITIONS = 'VBj9u0ot'
AI_TARGET_TYPE = '4xctV8gF'
AI_ACTION_PARAMS = 'Hhgi79M1'
AI_NAME = 'L8PCsu0K'
AI_TERM = 'q7Nit8JW'
AI_PRIORITY = 'yu18xScw'

ES_ID = 'cP83zNsv'
ES_NAME = '0nxpBDz2'
ES_TERM_PARAMS = 's2gM3deu'
ES_DESC = 'qp37xTDh'
ES_TARGET = 'moWQ30GH'

REQ_HEADER_TAG = 'F4q6i9xe'
REQ_ID = 'Hhgi79M1'
REQ_BODY_TAG = 'a3vSYuq2'
REQ_BODY = 'Kn51uR4Y'

ITEM_NAME = 'c7Z6xDB2'
ITEM_SHORTNAME = 'kP3zJ9Ra'
ITEM_RAIDFLG = 'ZKQ1X69a'
ITEM_RAIDUSAGETYPE = 'PEhNd0B4'
ITEM_RARITY = '7ofj5xa1'
ITEM_SELL_PRICE = 'eKtE6k0n'
ITEM_MAX_STACK = 'm9gd5h1u'
ITEM_ID = 'kixHbe54'
ITEM_MAX_EQUIPPED = 't1i2vIbT'
ITEM_PROCESS = '2Smu5Mtq'
ITEM_TARGET_TYPE = 'moWQ30GH'
ITEM_TARGET_AREA = '6E2fGPWT'
ITEM_TYPE = 'h0K7wjeH'
ITEM_THUMB = 'Mt3Y0bo5'
ITEM_KIND = '92udyUrJ'

RECIPE_ITEM_ID = 'kixHbe54'
RECIPE_MATERIALS = '75YV2q1i'
RECIPE_KARMA = 'HTVh8a65'

UNITTYPE_ID = 'nBTx56W9'
UNITTYPE_HP = '76IHLVsz'
UNITTYPE_ATK = '2M4mQZgk'
UNITTYPE_DEF = 'Sj9zR38K'
UNITTYPE_REC = '6D3YN9rc'

FE_ID = 'ri6D9yBi'
FE_NAME = 'yRlCNyvk'
FE_SERIES = '9PsmH7tz'
FE_LEVEL = 'D9wXQI2V'
FE_NEED_BP = 'G5wFDad6'
FE_CAT_ID = 'VgU78CYj'
FE_CAT_NAME = 'XLSB42ED'
FE_TERM_SKILL = 'FHThxDv4'
FE_TERM_COMMENT = '7XYkj2EU'
FE_EFFECT_TYPE = 'jeR2rN3V'

EVO_UNIT_ID = '74VFwuTd'
EVO_TYPE = 'dV3qji4I'
EVO_AMOUNT = 'Rs7bCE3t'
EVO_MAT_IDS = ['5it4IozN',
               'p5ZhN6Lk',
               '5F1qmcgX',
               'RHo1m0f6',
               'r9SEG7tR']
EVO_JP_MAT_TYPES = ['Xyt6rhx2',
                    '0tna4Idu',
                    '6GwnugW3',
                    'hdF8ND2H',
                    'nB7pFdR0',
                    'IZUvR489',
                    'bNRUuatB',
                    '2BFgYLjg',
                    '18Oz7z8k',
                    'EK7jR4rB']
EVO_JP_MAT_IDS = ['85X6JHQA',
                  'wh3YRU08',
                  '7MxucW2J',
                  'j7fTS3ca',
                  'Hb8yfmv7',
                  'Voht18AP',
                  '3g8brFoq',
                  'agp4CKEV',
                  'eKPWNoLn',
                  'MVidsUNV']

item_types = {
    '0': 'other',
    '1': 'consumable',
    '2': 'material',
    '3': 'sphere'
}

elements = {
    '0': 'all',
    '1': 'fire',
    '2': 'water',
    '3': 'earth',
    '4': 'thunder',
    '5': 'light',
    '6': 'dark',
}

ailments = {
    '1': 'poison%',
    '2': 'weaken%',
    '3': 'sick%',
    '4': 'injury%',
    '5': 'curse%',
    '6': 'paralysis%',
    '7': 'atk down',
    '8': 'def down',
    '9': 'rec down',
}

attribute = {
    '1': 'attack',
    '2': 'defense',
    '3': 'recovery',
    '4': 'hp'
}

item_kinds = {
    '0': 'Other',
    '1': 'Status Boost',
    '2': 'Critical',
    '3': 'Drop',
    '4': 'Status Ailment',
    '5': 'Status Ailments Resistant',
    '6': 'BB Gauge',
    '7': 'HP Recovery',
    '8': 'Expose Target',
    '9': 'Damage Reflecting',
    '10': 'Damage Reducing',
    '11': 'Spark',
    '12': 'Defense Penetrating',
    '13': 'Atk Boosting',
    '14': 'Special'
}


target_type_names = {
    '1': 'party',
    '2': 'enemy',
    '3': 'self'
}

target_area_names = {
    '1': 'single',
    '2': 'aoe'
}

gender = {
    '0': 'other',
    '1': 'male',
    '2': 'female'
}

caution = {
    '0': False,
    '1': True,
}

bool_str = {
    '0': False,
    '1': True,
}

move_types = {
    '1': 'normal',
    '2': 'other',
    '3': 'no move'
}

buff_lookup = {
    '1': 'atk% buff',
    '2': 'atk% buff',
    '3': 'def% buff',
    '4': 'def% buff',
    '5': 'rec% buff',
    '7': 'crit% buff',
    '8': 'gradual heal turns',
    '9': 'hc drop rate% buff',
    '10': 'bc drop rate% buff',
    '11': 'item drop rate% buff',
    '12': 'angel idol effect',
    # fire
    '13': 'atk% buff',
    '14': 'def% buff',
    '15': 'rec% buff',
    # water
    '16': 'atk% buff',
    '17': 'def% buff',
    '18': 'rec% buff',
    # earth
    '19': 'atk% buff',
    '20': 'def% buff',
    '21': 'rec% buff',
    # thunder
    '22': 'atk% buff',
    '23': 'def% buff',
    '24': 'rec% buff',
    # light
    '25': 'atk% buff',
    '26': 'def% buff',
    '27': 'rec% buff',
    # dark
    '28': 'atk% buff',
    '29': 'def% buff',
    '30': 'rec% buff',
    '36': 'dmg% reduction',
    '37': 'increase bb gauge gradual',
    '38': 'bc fill when attacked',
    '39': 'defense% ignore',
    '40': 'spark dmg% buff',
    '46': 'atk% buff',
    '47': 'def% buff',
    '50': 'hit increase buff',
    '71': 'dot',
    '72': 'bb atk% buff'
}

get_type = {
    '1': 'farmable',
    '2': 'rare summon',
    '3': 'not eligible for achievement'
}

unit_kind = {
    '0': 'normal',
    '1': 'evo',
    '2': 'enhancing',
    '3': 'sale'
}

unit_type = {
    '1': 'lord',
    '2': 'anima',
    '3': 'breaker',
    '4': 'guardian',
    '5': 'oracle',
    '6': 'rex'
}

move_speed_1 = {
    '0': 0.002,
    '1': 0.005,
    '2': 0.0041,
    '3': 0.0033,
    '4': 0.0024,
    '5': 0.0015
}

move_speed_other = {
    '0': 0,
    '1': 8,
    '2': 6,
    '3': 4,
    '4': 2,
    '5': 0
}

move_speed = {
    '1': move_speed_1,  # move
    '2': move_speed_other,  # teleport
    '3': move_speed_other  # no move, speed correspond to no. of frames waiting in move
}

animation_type = {
    '1': 'idle',
    '2': 'move',
    '3': 'attack',
    '4': 'altattack'
}

passive_target = {
    '1': 'self',
    '2': 'party'
}


def crit_elem_weakness(x):
    return float(x) * 100


def damage_range(atk):
    return (int((atk * 0.9) + (atk / 32)),
            int(atk + (atk / 25)))


def damage_range_bb(unit, skill, bb_level):
    #bb_level = bb_levels[-1]
    total_atk = unit['lord atk']
    modifier = bb_level['bb atk%']
    modifier += bb_level.get('atk% buff', 0)

    total_atk = total_atk * (1 + float(modifier) / 100)
    total_atk += bb_level.get('bb flat atk', 0)
    total_atk = total_atk * (1 + float(bb_level.get('bb dmg%', 0))
                             / 100)
    total_atk = total_atk * float(sum(
        skill.get('hit dmg% distribution', [100]))) / 100
    total_atk = int(total_atk)
    return damage_range(total_atk)


def dmg_str(limits):
    return '~'.join(map(str, limits))


def not_zero(a):
    if a == None:
        return False
    if len(a) == 0:
        return False
    try:
        return int(a) != 0
    except:
        return False


def not_empty(a):
    if a == None:
        return False
    if len(a) == 0:
        return False
    return True


def bb_gauge(a):
    return int(a) / 100


def hits(atk_frames):
    return len(atk_frames.split(','))


def hit_dmg_dist(atk_frames):
    if atk_frames == '0':
        return []
    return [intTryParse(hit.split(':')[1]) if len(hit.split(':')) > 1 else 0
        for hit in atk_frames.split(',')]

def frame_time_dist(atk_frames):
    if atk_frames == '0':
        return []
    return [intTryParse(hit.split(':')[0]) if len(hit.split(':')) > 1 else 0
        for hit in atk_frames.split(',')]

def hit_dmg_dist_total(atk_frames):
    if atk_frames == '0':
        return 0
    return sum([intTryParseZero(hit.split(':')[1]) if len(hit.split(':')) > 1 else 0
        for hit in atk_frames.split(',')])

def parse_imps(args):
    return {'max hp': args[0],
            'max atk': args[1],
            'max def': args[2],
            'max rec': args[3]}


def second_int(_, a):
    return int(a)


def intTryParse(value):
    try:
        return int(value)
    except ValueError:
        return value


def intTryParseZero(value):
    try:
        return int(value)
    except ValueError:
        return 0


def get_dict_str(dictionary):
    return lambda s: dictionary.get(s, s)


def get_unit_name(dictionary, id, jp=True):
    return lambda s: dictionary.get(s, s) if (jp or id == None) else dictionary.get('MST_UNIT_' + id + '_NAME', s)


def get_skill_name(dictionary, id, jp=True):
    return lambda s: dictionary.get(s, s) if (jp or id == None) else dictionary.get('MST_SKILLS_' + id + '_NAME', s)


def get_skill_desc(dictionary, id, jp=True):
    return lambda s: dictionary.get(s, s) if (jp or id == None) else dictionary.get('MST_SKILLS_' + id + '_DESCRIPTION', s)


def get_es_name(dictionary, id, jp=True):
    return lambda s: dictionary.get(s, s) if (jp or id == None) else dictionary.get('MST_EXTRAPASSIVESKILL_' + id + '_NAME', s)


def get_es_desc(dictionary, id, jp=True):
    return lambda s: dictionary.get(s, s) if (jp or id == None) else dictionary.get('MST_EXTRAPASSIVESKILL_' + id + '_DESCRIPTION', s)


def get_ls_name(dictionary, id, jp=True):
    return lambda s: dictionary.get(s, s) if (jp or id == None) else dictionary.get('MST_LEADERSKILLS_' + id + '_NAME', s)


def get_ls_desc(dictionary, id, jp=True):
    return lambda s: dictionary.get(s, s) if (jp or id == None) else dictionary.get('MST_LEADERSKILLS_' + id + '_DESCRIPTION', s)


def get_fe_name(dictionary, id, jp=True):
    return lambda s: dictionary.get(s, s) if (jp or id == None) else dictionary.get('MST_FE_SKILLS_' + id + '_NAME', s)


def get_fe_desc(dictionary, id, jp=True):
    return lambda s: dictionary.get(s, s) if (jp or id == None) else dictionary.get('MST_FE_SKILLS_' + id + '_DESC', s)


def get_item_name(dictionary, id, s, jp=True):
    if jp:
        return dictionary.get(s, s)
    else:
        if 'MST_ITEMS_MATERIAL_' + id + '_NAME' in dictionary:
            return dictionary['MST_ITEMS_MATERIAL_' + id + '_NAME']
        if 'MST_ITEMS_BATTLEITEMS_' + id + '_NAME' in dictionary:
            return dictionary['MST_ITEMS_BATTLEITEMS_' + id + '_NAME']
        if 'MST_SPHERES_' + id + '_NAME' in dictionary:
            return dictionary['MST_SPHERES_' + id + '_NAME']
        if 'MST_EVOITEM_' + id + '_NAME' in dictionary:
            return dictionary['MST_EVOITEM_' + id + '_NAME']
        if 'MST_LSSPHERE_' + id + '_NAME' in dictionary:
            return dictionary['MST_LSSPHERE_' + id + '_NAME']
        return s


def get_item_desc(dictionary, id, s, jp=True):
    if jp:
        return dictionary.get(s, s)
    else:
        if 'MST_ITEMS_MATERIAL_' + id + '_SHORTDESCRIPTION' in dictionary:
            return dictionary['MST_ITEMS_MATERIAL_' + id + '_SHORTDESCRIPTION']
        if 'MST_ITEMS_BATTLEITEMS_' + id + '_SHORTDESCRIPTION' in dictionary:
            return dictionary['MST_ITEMS_BATTLEITEMS_' + id + '_SHORTDESCRIPTION']
        if 'MST_SPHERES_' + id + '_SHORTDESCRIPTION' in dictionary:
            return dictionary['MST_SPHERES_' + id + '_SHORTDESCRIPTION']
        if 'MST_EVOITEM_' + id + '_SHORTDESCRIPTION' in dictionary:
            return dictionary['MST_EVOITEM_' + id + '_SHORTDESCRIPTION']
        if 'MST_LSSPHERE_' + id + '_SHORTDESCRIPTION' in dictionary:
            return dictionary['MST_LSSPHERE_' + id + '_SHORTDESCRIPTION']
        return s


def handle_format(fmt, obj):
    """Applies a specified format onto an object

    Args:
        fmt: A tuple whose elements are either functions which are applied on obj, or 4-tuples with
             the first element being indices into obj, second element being the resulting key name,
             the third element being the value of the key, or a function that accepts the obj args
             specified in the first element and returns a value, and the optional fourth element is
             a predicate that accepts the obj args specified in the first element to determine
             whether to add this key.
        obj: An object that implements __getitem__
    """
    import inspect

    data = {}
    for entry in fmt:
        if hasattr(entry, '__call__'):
            data.update(entry(obj))
            continue

        indices = entry[0]
        if not hasattr(indices, '__iter__'):
            indices = [indices]

        key = entry[1]
        value = entry[2]
        if len(entry) > 3:
            predicate = entry[3]
        else:
            def predicate(x): return True

        skip = False
        for idx in indices:
            skip |= type(idx) == int and idx >= len(obj)
            skip |= type(idx) != int and idx not in obj

        if skip:
            continue

        args = map(obj.__getitem__, indices) + [data]

        def _call(fn, args):
            try:
                num_args = len(inspect.getargspec(fn).args)
            except TypeError:
                num_args = 1
            return fn(*args[:num_args])

        if _call(predicate, args) is not True:
            continue

        if hasattr(key, '__call__'):
            key = _call(key, args)

        if hasattr(value, '__call__'):
            value = _call(value, args)

        data[key] = value

    return data
